// nice library for quickly implementing and handling cameras in 3D scenes

import lib/devices/input/joystick.a
import lib/devices/math/matrix.a

class Camera {
	// input methods
	
	Joystick->var joystick;
	
	// matrices
	
	Matrix->var model_view_matrix;
	Matrix->var projection_matrix;
	
	Matrix->var model_view_projection_matrix;
	
	// parameters (all values starting with an underscore are transition values)
	
	var orbit;
	
	fixed var _fov; fixed var fov; // field of view
	
	fixed var _rx; fixed var rx; // rotation around yaw axis
	fixed var _ry; fixed var ry; // rotation around pitch axis
	fixed var _rz; fixed var rz; // rotation around roll axis
	
	fixed var _px; fixed var px; // left / right position
	fixed var _py; fixed var py; // up / down position
	fixed var _pz; fixed var pz; // forwards / backwards position
	
	fixed var _distance; fixed var distance;
	
	func construct(var orbit, Matrix->var model_view_projection_matrix, Joystick->var joystick) {
		// input methods
		
		self.joystick = joystick;
		
		// matrices
		
		self.model_view_matrix = new(Matrix).construct();
		self.model_view_matrix.identity();
		
		self.projection_matrix = new(Matrix).construct();
		self.model_view_projection_matrix = model_view_projection_matrix;
		
		// parameters
		
		self.orbit = orbit;
		self.fov = Math.TAU / 4;
		
		if (self.orbit) {
			self.distance = 3.0; // default orbit distance
		}
		
		return self;
	}
	
	func update(var fps) {
		// getting rotation inputs
		
		if (self.joystick) {
			//~ if (self.orbit) {
				//~ self.rx = self.rx - self.joystick.axis(2) / fps * 5;
				//~ self.ry = self.ry + self.joystick.axis(3) / fps * 5;
				
			//~ } else {
				self.rx = self.rx + self.joystick.axis(2) / fps * 4;
				self.ry = self.ry - self.joystick.axis(3) / fps * 4;
			//~ }
		}
		
		if (self.ry >  Math.TAU / 4) self.ry =  Math.TAU / 4;
		if (self.ry < -Math.TAU / 4) self.ry = -Math.TAU / 4;
		
		// getting strafe inputs
		var strafex = 0.0; var strafey = 0.0;
		
		if (self.joystick) {
			strafex = strafex + self.joystick.axis(0);
			strafey = strafey - self.joystick.axis(1);
		}
		
		if (strafex or strafey) {
			var player_speed = 1.0;
			
			var strafe = Math.atan2(strafey, strafex);
			var speed = fixed Math.max(Math.min(Math.sqrt(strafex * strafex + strafey * strafey) * player_speed, player_speed), -player_speed);
			
			self.px = self.px + speed * Math.cos(self._rx - strafe) / fps * 10;
			self.pz = self.pz + speed * Math.sin(self._rx - strafe) / fps * 10;
			
		}
		
		// updating parameters
		
		self._fov = self._fov + (self.fov - self._fov) / fps * 5;
		
		self._rx = self._rx + (self.rx - self._rx) / fps * 10;
		self._ry = self._ry + (self.ry - self._ry) / fps * 10;
		self._rz = self._rz + (self.rz - self._rz) / fps * 10;
		
		self._px = self._px + (self.px - self._px) / fps * 10;
		self._py = self._py + (self.py - self._py) / fps * 10;
		self._pz = self._pz + (self.pz - self._pz) / fps * 10;
		
		if (self.orbit) {
			self._distance = self._distance + (self.distance - self._distance) / fps * 10;
		}
		
		// matrices
		
		self.projection_matrix.identity();
		self.projection_matrix.perspective self._fov, (fixed video_width()) / fixed video_height(), 100000, 500000000;
		
		self.model_view_matrix.identity();
		
		if (self.orbit) {
			self.model_view_matrix.translate 0, 0, -self._distance;
		}
		
		self.model_view_matrix.rotate_2d self._rx, self._ry, self._rz;
		self.model_view_matrix.translate -self._px, -self._py, -self._pz;
		
		self.model_view_projection_matrix.set self.model_view_matrix;
		self.model_view_projection_matrix.multiply self.projection_matrix;
	}
}
