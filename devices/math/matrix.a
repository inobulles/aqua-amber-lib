// quickly calculate matrix transformations

import lib/device.a
import lib/math.a

class Matrix {
	var matrix;
	Device->var device;
	var matrix_bytes;
	
	func construct {
		self.device = new(Device).construct("matrix");
		self.matrix_bytes = ?self.device.send(0x62);
		self.matrix = new(self.matrix_bytes);
		
		return self;
	}
	
	func identity self.device.send 0x69, self.matrix;
	func set(Matrix->var matrix) mcpy self.matrix, matrix.matrix, self.matrix_bytes;
	func multiply(Matrix->var matrix) self.device.send 0x6D, self.matrix, self.matrix, matrix.matrix;
	
	func scale(var x, var y, var z) self.device.send 0x73, self.matrix, self.matrix, x, y, z;
	func translate(var x, var y, var z) self.device.send 0x74, self.matrix, self.matrix, x, y, z;
	func rotate(var angle, var x, var y, var z) self.device.send 0x72, self.matrix, self.matrix, angle, x, y, z;
	
	func rotate_2d(var x, var y) {
		self.rotate(x, 0, PRECISION, 0);
		self.rotate(-y, Math.cos(x), 0, Math.sin(x));
	}
	
	func __camera(var command, var left, var right, var bottom, var top, var near, var far) {
		var arguments = new(8 * 8);
		
		?(arguments + 0x00) = command;
		?(arguments + 0x08) = self.matrix;
		
		?(arguments + 0x10) = left;
		?(arguments + 0x18) = right;
		?(arguments + 0x20) = bottom;
		?(arguments + 0x28) = top;
		?(arguments + 0x30) = near;
		?(arguments + 0x38) = far;
		
		self.device.send_pointer arguments;
		mfree arguments, 8 * 8;
	}
	
	// note for camera functions:
	//     The way the "frustum" function works in the matrix device is not standard.
	//     The left, right, bottom, and top parameters tell the dimensions of the camera plane at Z = 1, not at Z = near.
	//     They are multiplied by near by the matrix device to conserve precision.
	
	func frustum(var left, var right, var bottom, var top, var near, var far) self.__camera 0x66, left, right, bottom, top, near, far;
	func ortho(var left, var right, var bottom, var top, var near, var far) self.__camera 0x6F, left, right, bottom, top, near, far;
	
	func perspective(var fovy, var aspect, var near, var far) {
		var frustum_y = Math.tan(fovy / 2);
		var frustum_x = Math.mul_float(frustum_y, aspect);
		
		self.frustum(-frustum_x, frustum_x, -frustum_y, frustum_y, near, far);
	}
}
